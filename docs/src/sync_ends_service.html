<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>src.sync_ends_service API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.sync_ends_service</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Standard library imports
import http.client
import json
import os
import time
import ssl

# Third party imports
from slack import WebClient
from src.collection import Collection

ssl._create_default_https_context = ssl._create_unverified_context


class SyncEnd:
    &#34;&#34;&#34;
    A class to represent the SyncEnd object in the code. This object contains \
    the methods that serve as the interface for the \
    package with Postman and Slack.

    Attributes
    ----------
        api_key : API key for Postman to fetch collections
        collection_name : Postman collection name from which to fetch APIs&#39; \
schema
        trigger_interval : interval (in seconds) post which to again fetch \
APIs schemas
        slack_channel : Slack channel name where the message will be sent
        slack_token : Slack Bot token to authorize the sending of message
        collection_id : ID of Postman collection
    &#34;&#34;&#34;

    def __init__(
        self,
        api_key,
        collection_name,
        trigger_interval,
        slack_channel,
        slack_token,
    ):
        self.api_key = api_key
        self.collection_name = collection_name
        self.trigger_interval = trigger_interval
        self.slack_channel = slack_channel
        self.slack_token = slack_token
        self.collection_id = 0

    def get_collection_schema(self):
        &#34;&#34;&#34;
        Fetches the APIs schemas from the Postman collection
        &#34;&#34;&#34;

        boundary = &#34;&#34;
        payload = &#34;&#34;
        headers = {
            &#34;X-Api-Key&#34;: self.api_key,
            &#34;Content-type&#34;: &#34;multipart/form-data; boundary={}&#34;.format(boundary),  # noqa: E501
        }

        # create a HTTPS connection object
        connection = http.client.HTTPSConnection(&#34;api.getpostman.com&#34;)
        connection.request(&#34;GET&#34;, &#34;/collections&#34;, payload, headers)
        response = connection.getresponse()
        collections = json.loads(response.read())
        collection = list(
            filter(
                lambda x: self.collection_name == x[&#34;name&#34;],
                collections.get(&#34;collections&#34;),
            )
        )

        # if collection is empty, it is an invalid connection
        if len(collection) == 0:
            raise NameError(&#34;Invalid collection name !!!&#34;)

        self.collection_id = collection[0][&#34;uid&#34;]
        connection.request(
            &#34;GET&#34;, &#34;/collections/&#34; + self.collection_id, payload, headers
        )

        # fetch the response and load the API schema as a JSON
        collection_schema_response = connection.getresponse()
        return json.loads(collection_schema_response.read())

    def post_data_to_slack(self, data):
        &#34;&#34;&#34;
        Posts the messages for APIs added, deleted and updated based on the \
        input data

        Inputs
        ----------
            data : list of strings pertaining to APIs added, deleted and \
updated
        &#34;&#34;&#34;
        slack_web_client = WebClient(
            # Add the slack access token here
            token=self.slack_token
        )

        for x in data:
            if x is not None and len(x) &gt; 0:
                message = {
                    &#34;channel&#34;: self.slack_channel,
                    &#34;blocks&#34;: [
                        {
                            &#34;type&#34;: &#34;section&#34;,
                            &#34;text&#34;: {&#34;type&#34;: &#34;plain_text&#34;, &#34;text&#34;: x},
                        }
                    ],
                }
                slack_web_client.chat_postMessage(**message)

    def get_newly_added_message(self, end_point_list):
        &#34;&#34;&#34;
        Returns the message string for each API end point added to the \
        collection

        Inputs
        ----------
            end_point_list : list of endpoints which are newly added to the \
collection
        &#34;&#34;&#34;
        title = &#34;Following end points are newly added in the collection :: \n\n&#34;  # noqa: E501
        output = &#34;&#34;
        for i, end_point in enumerate(end_point_list):
            output = (
                output
                + &#34;\t&#34;
                + str(i + 1)
                + &#34;)  &#34;
                + end_point.name
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;URL: &#34;
                + end_point.url
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;Request Method: &#34;
                + end_point.method
                + &#34;\n\n&#34;
            )
        if output == &#34;&#34;:
            return None
        return title + output

    def get_delete_message(self, end_point_list):
        &#34;&#34;&#34;
        Returns the message string for each API end point deleted from the \
        collection

        Inputs
        ----------
            end_point_list : list of endpoints which are deleted from the \
collection
        &#34;&#34;&#34;
        title = &#34;Following end points are deleted from the collection :: \n\n&#34;
        output = &#34;&#34;
        for i, end_point in enumerate(end_point_list):
            output = (
                output
                + &#34;\t&#34;
                + str(i + 1)
                + &#34;)  &#34;
                + &#34;EndPoint Name: &#34;
                + end_point.name
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;URL: &#34;
                + end_point.url
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;Request Method: &#34;
                + end_point.method
                + &#34;\n\n&#34;
            )
        if output == &#34;&#34;:
            return None
        return title + output

    def get_updated_end_point_message(self, common_end_points):
        &#34;&#34;&#34;
        Returns the message string for each API end point updated in the \
        collection

        Inputs
        ----------
            common_end_points : list of endpoints (APIs) which are modified \
in the collection
        &#34;&#34;&#34;
        title = &#34;Following is the list of change in the existing end points ::\n\n&#34;  # noqa: E501
        difference = &#34;&#34;
        for end_point_tuple in common_end_points:
            difference = &#34;&#34;
            new_end_point = end_point_tuple[0]
            old_end_point = end_point_tuple[1]

            # compute change in name
            if new_end_point.name != old_end_point.name:
                difference += (
                    &#34;\tNew name: &#34;
                    + new_end_point.name
                    + &#34; &#34;
                    + &#34;\nOld name: &#34;
                    + old_end_point.name
                    + &#34;\n&#34;
                )

            if new_end_point.url != old_end_point.url:
                difference += (
                    &#34;\tNew URL: &#34;
                    + new_end_point.url
                    + &#34; &#34;
                    + &#34;\nOld URL: &#34;
                    + old_end_point.url
                    + &#34;\n&#34;
                )

            # compute change in authentication
            if new_end_point.authentication != old_end_point.authentication:
                if new_end_point.authentication is None:
                    difference += &#34;\tNew Authentication: None&#34;
                else:
                    difference += (
                        &#34;\tNew Authentication: Key :&#34;
                        + new_end_point.authentication[&#34;apikey&#34;][1][&#34;value&#34;]
                        + &#34;, Value : &#34;
                        + new_end_point.authentication[&#34;apikey&#34;][0][&#34;value&#34;]
                        + &#34;\n&#34;
                    )

            # Compute change in the HTTP request type
            if new_end_point.method != old_end_point.method:
                difference += (
                    &#34;\t New HTTP method: &#34;
                    + new_end_point.method
                    + &#34; &#34;
                    + &#34;\nOld HTTP method: &#34;
                    + old_end_point.method
                    + &#34;\n&#34;
                )

        if difference == &#34;&#34;:
            return None

        return title + difference

    def compute_difference(self, new_collection_schema):
        &#34;&#34;&#34;
        Computes the difference between the new and the old collection \
        schema. The old collection schema is stored as a file in the \
        data/ directory.

        Inputs
        ----------
            new_collection_schema : dictionary representing the collection \
schema fetched through the Postman API
        &#34;&#34;&#34;

        # specify the filepath for the collection schema, create the file if \
        # not already present
        filepath = &#34;./data/&#34; + self.collection_id + &#34;.txt&#34;
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        if not os.path.exists(filepath):
            with open(filepath, &#34;w&#34;) as file:
                # file.write(&#34;{\&#34;item\&#34;:[]}&#34;)
                file.write(json.dumps(new_collection_schema.get(&#34;collection&#34;)))

        # the old (previous) collection schema is stored as a file in data/
        file = open(filepath, &#34;r&#34;)
        old_collection_schema = json.load(file)

        # read the data from file and convert it to collection object
        old_schema_obj = Collection(old_collection_schema)
        new_collection_obj = Collection(
            new_collection_schema.get(&#34;collection&#34;)
        )  # noqa: E501

        # iterate over each new endpoint(API) in the collection and compare
        # with old endpoint
        common_end_points = []
        for new_end_point in new_collection_obj.get_end_points():
            for old_end_point in old_schema_obj.get_end_points():

                # if same id endpoint in both old and new schemas, add it
                # to common_end_points, remove it from old endpoints
                # and new endpoints
                if new_end_point.id == old_end_point.id:
                    # if same id ,
                    # append it to common_end_points list
                    common_end_points.append((new_end_point, old_end_point))
                    old_schema_obj.remove_end_point(old_end_point)
                    new_collection_obj.remove_end_point(new_end_point)

        # at the end of above for loop, the 3 objects store the following information:  # noqa: E501
        # old_schema_obj - only those endpoints which are now deleted from the collection  # noqa: E501
        # new_collection_obj - only those endpoints which have been added to the collection  # noqa: E501
        # common_end_points - only those endpoints which are common b/w old and new collection schemas  # noqa: E501

        newly_added_end_point = self.get_newly_added_message(
            new_collection_obj.get_end_points()
        )

        deleted_end_points = self.get_delete_message(old_schema_obj.get_end_points())  # noqa: E501

        updated_end_point = self.get_updated_end_point_message(common_end_points)  # noqa: E501

        message = [
            newly_added_end_point,
            deleted_end_points,
            updated_end_point,
        ]

        return message

    def store_file(self, new_collection):
        &#34;&#34;&#34;
        Stores the collection schema as a txt file in data/ directory. This \
        will be used to fetch the schema in compute_difference().

        Inputs
        ----------
            new_collection : collection schema to be saved in the file
        &#34;&#34;&#34;
        filepath = &#34;./data/&#34; + self.collection_id + &#34;.txt&#34;
        with open(filepath, &#34;w&#34;) as file:
            file.write(json.dumps(new_collection.get(&#34;collection&#34;)))

    def start(self):
        &#34;&#34;&#34;
        Main driver function which is called from main.py to run CLI. \
        This function fetches the new collection schema through Postman API.
        Then, it computes the difference with old schema and posts the \
        relevant messages to Slack channel.
        Finally, it overwrites the new schema fetched through the API in the \
        file.
        &#34;&#34;&#34;
        while True:

            # get the current configuration of the schema
            new_collection_schema = self.get_collection_schema()

            # compute the difference with the previous schema
            difference = self.compute_difference(new_collection_schema)

            # post the difference to the slack
            self.post_data_to_slack(difference)

            # store new schema to the file
            self.store_file(new_collection_schema)

            time.sleep(self.trigger_interval)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.sync_ends_service.SyncEnd"><code class="flex name class">
<span>class <span class="ident">SyncEnd</span></span>
<span>(</span><span>api_key, collection_name, trigger_interval, slack_channel, slack_token)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to represent the SyncEnd object in the code. This object contains
the methods that serve as the interface for the
package with Postman and Slack.</p>
<h2 id="attributes">Attributes</h2>
<pre><code>api_key : API key for Postman to fetch collections
collection_name : Postman collection name from which to fetch APIs' schema
trigger_interval : interval (in seconds) post which to again fetch APIs schemas
slack_channel : Slack channel name where the message will be sent
slack_token : Slack Bot token to authorize the sending of message
collection_id : ID of Postman collection
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SyncEnd:
    &#34;&#34;&#34;
    A class to represent the SyncEnd object in the code. This object contains \
    the methods that serve as the interface for the \
    package with Postman and Slack.

    Attributes
    ----------
        api_key : API key for Postman to fetch collections
        collection_name : Postman collection name from which to fetch APIs&#39; \
schema
        trigger_interval : interval (in seconds) post which to again fetch \
APIs schemas
        slack_channel : Slack channel name where the message will be sent
        slack_token : Slack Bot token to authorize the sending of message
        collection_id : ID of Postman collection
    &#34;&#34;&#34;

    def __init__(
        self,
        api_key,
        collection_name,
        trigger_interval,
        slack_channel,
        slack_token,
    ):
        self.api_key = api_key
        self.collection_name = collection_name
        self.trigger_interval = trigger_interval
        self.slack_channel = slack_channel
        self.slack_token = slack_token
        self.collection_id = 0

    def get_collection_schema(self):
        &#34;&#34;&#34;
        Fetches the APIs schemas from the Postman collection
        &#34;&#34;&#34;

        boundary = &#34;&#34;
        payload = &#34;&#34;
        headers = {
            &#34;X-Api-Key&#34;: self.api_key,
            &#34;Content-type&#34;: &#34;multipart/form-data; boundary={}&#34;.format(boundary),  # noqa: E501
        }

        # create a HTTPS connection object
        connection = http.client.HTTPSConnection(&#34;api.getpostman.com&#34;)
        connection.request(&#34;GET&#34;, &#34;/collections&#34;, payload, headers)
        response = connection.getresponse()
        collections = json.loads(response.read())
        collection = list(
            filter(
                lambda x: self.collection_name == x[&#34;name&#34;],
                collections.get(&#34;collections&#34;),
            )
        )

        # if collection is empty, it is an invalid connection
        if len(collection) == 0:
            raise NameError(&#34;Invalid collection name !!!&#34;)

        self.collection_id = collection[0][&#34;uid&#34;]
        connection.request(
            &#34;GET&#34;, &#34;/collections/&#34; + self.collection_id, payload, headers
        )

        # fetch the response and load the API schema as a JSON
        collection_schema_response = connection.getresponse()
        return json.loads(collection_schema_response.read())

    def post_data_to_slack(self, data):
        &#34;&#34;&#34;
        Posts the messages for APIs added, deleted and updated based on the \
        input data

        Inputs
        ----------
            data : list of strings pertaining to APIs added, deleted and \
updated
        &#34;&#34;&#34;
        slack_web_client = WebClient(
            # Add the slack access token here
            token=self.slack_token
        )

        for x in data:
            if x is not None and len(x) &gt; 0:
                message = {
                    &#34;channel&#34;: self.slack_channel,
                    &#34;blocks&#34;: [
                        {
                            &#34;type&#34;: &#34;section&#34;,
                            &#34;text&#34;: {&#34;type&#34;: &#34;plain_text&#34;, &#34;text&#34;: x},
                        }
                    ],
                }
                slack_web_client.chat_postMessage(**message)

    def get_newly_added_message(self, end_point_list):
        &#34;&#34;&#34;
        Returns the message string for each API end point added to the \
        collection

        Inputs
        ----------
            end_point_list : list of endpoints which are newly added to the \
collection
        &#34;&#34;&#34;
        title = &#34;Following end points are newly added in the collection :: \n\n&#34;  # noqa: E501
        output = &#34;&#34;
        for i, end_point in enumerate(end_point_list):
            output = (
                output
                + &#34;\t&#34;
                + str(i + 1)
                + &#34;)  &#34;
                + end_point.name
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;URL: &#34;
                + end_point.url
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;Request Method: &#34;
                + end_point.method
                + &#34;\n\n&#34;
            )
        if output == &#34;&#34;:
            return None
        return title + output

    def get_delete_message(self, end_point_list):
        &#34;&#34;&#34;
        Returns the message string for each API end point deleted from the \
        collection

        Inputs
        ----------
            end_point_list : list of endpoints which are deleted from the \
collection
        &#34;&#34;&#34;
        title = &#34;Following end points are deleted from the collection :: \n\n&#34;
        output = &#34;&#34;
        for i, end_point in enumerate(end_point_list):
            output = (
                output
                + &#34;\t&#34;
                + str(i + 1)
                + &#34;)  &#34;
                + &#34;EndPoint Name: &#34;
                + end_point.name
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;URL: &#34;
                + end_point.url
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;Request Method: &#34;
                + end_point.method
                + &#34;\n\n&#34;
            )
        if output == &#34;&#34;:
            return None
        return title + output

    def get_updated_end_point_message(self, common_end_points):
        &#34;&#34;&#34;
        Returns the message string for each API end point updated in the \
        collection

        Inputs
        ----------
            common_end_points : list of endpoints (APIs) which are modified \
in the collection
        &#34;&#34;&#34;
        title = &#34;Following is the list of change in the existing end points ::\n\n&#34;  # noqa: E501
        difference = &#34;&#34;
        for end_point_tuple in common_end_points:
            difference = &#34;&#34;
            new_end_point = end_point_tuple[0]
            old_end_point = end_point_tuple[1]

            # compute change in name
            if new_end_point.name != old_end_point.name:
                difference += (
                    &#34;\tNew name: &#34;
                    + new_end_point.name
                    + &#34; &#34;
                    + &#34;\nOld name: &#34;
                    + old_end_point.name
                    + &#34;\n&#34;
                )

            if new_end_point.url != old_end_point.url:
                difference += (
                    &#34;\tNew URL: &#34;
                    + new_end_point.url
                    + &#34; &#34;
                    + &#34;\nOld URL: &#34;
                    + old_end_point.url
                    + &#34;\n&#34;
                )

            # compute change in authentication
            if new_end_point.authentication != old_end_point.authentication:
                if new_end_point.authentication is None:
                    difference += &#34;\tNew Authentication: None&#34;
                else:
                    difference += (
                        &#34;\tNew Authentication: Key :&#34;
                        + new_end_point.authentication[&#34;apikey&#34;][1][&#34;value&#34;]
                        + &#34;, Value : &#34;
                        + new_end_point.authentication[&#34;apikey&#34;][0][&#34;value&#34;]
                        + &#34;\n&#34;
                    )

            # Compute change in the HTTP request type
            if new_end_point.method != old_end_point.method:
                difference += (
                    &#34;\t New HTTP method: &#34;
                    + new_end_point.method
                    + &#34; &#34;
                    + &#34;\nOld HTTP method: &#34;
                    + old_end_point.method
                    + &#34;\n&#34;
                )

        if difference == &#34;&#34;:
            return None

        return title + difference

    def compute_difference(self, new_collection_schema):
        &#34;&#34;&#34;
        Computes the difference between the new and the old collection \
        schema. The old collection schema is stored as a file in the \
        data/ directory.

        Inputs
        ----------
            new_collection_schema : dictionary representing the collection \
schema fetched through the Postman API
        &#34;&#34;&#34;

        # specify the filepath for the collection schema, create the file if \
        # not already present
        filepath = &#34;./data/&#34; + self.collection_id + &#34;.txt&#34;
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        if not os.path.exists(filepath):
            with open(filepath, &#34;w&#34;) as file:
                # file.write(&#34;{\&#34;item\&#34;:[]}&#34;)
                file.write(json.dumps(new_collection_schema.get(&#34;collection&#34;)))

        # the old (previous) collection schema is stored as a file in data/
        file = open(filepath, &#34;r&#34;)
        old_collection_schema = json.load(file)

        # read the data from file and convert it to collection object
        old_schema_obj = Collection(old_collection_schema)
        new_collection_obj = Collection(
            new_collection_schema.get(&#34;collection&#34;)
        )  # noqa: E501

        # iterate over each new endpoint(API) in the collection and compare
        # with old endpoint
        common_end_points = []
        for new_end_point in new_collection_obj.get_end_points():
            for old_end_point in old_schema_obj.get_end_points():

                # if same id endpoint in both old and new schemas, add it
                # to common_end_points, remove it from old endpoints
                # and new endpoints
                if new_end_point.id == old_end_point.id:
                    # if same id ,
                    # append it to common_end_points list
                    common_end_points.append((new_end_point, old_end_point))
                    old_schema_obj.remove_end_point(old_end_point)
                    new_collection_obj.remove_end_point(new_end_point)

        # at the end of above for loop, the 3 objects store the following information:  # noqa: E501
        # old_schema_obj - only those endpoints which are now deleted from the collection  # noqa: E501
        # new_collection_obj - only those endpoints which have been added to the collection  # noqa: E501
        # common_end_points - only those endpoints which are common b/w old and new collection schemas  # noqa: E501

        newly_added_end_point = self.get_newly_added_message(
            new_collection_obj.get_end_points()
        )

        deleted_end_points = self.get_delete_message(old_schema_obj.get_end_points())  # noqa: E501

        updated_end_point = self.get_updated_end_point_message(common_end_points)  # noqa: E501

        message = [
            newly_added_end_point,
            deleted_end_points,
            updated_end_point,
        ]

        return message

    def store_file(self, new_collection):
        &#34;&#34;&#34;
        Stores the collection schema as a txt file in data/ directory. This \
        will be used to fetch the schema in compute_difference().

        Inputs
        ----------
            new_collection : collection schema to be saved in the file
        &#34;&#34;&#34;
        filepath = &#34;./data/&#34; + self.collection_id + &#34;.txt&#34;
        with open(filepath, &#34;w&#34;) as file:
            file.write(json.dumps(new_collection.get(&#34;collection&#34;)))

    def start(self):
        &#34;&#34;&#34;
        Main driver function which is called from main.py to run CLI. \
        This function fetches the new collection schema through Postman API.
        Then, it computes the difference with old schema and posts the \
        relevant messages to Slack channel.
        Finally, it overwrites the new schema fetched through the API in the \
        file.
        &#34;&#34;&#34;
        while True:

            # get the current configuration of the schema
            new_collection_schema = self.get_collection_schema()

            # compute the difference with the previous schema
            difference = self.compute_difference(new_collection_schema)

            # post the difference to the slack
            self.post_data_to_slack(difference)

            # store new schema to the file
            self.store_file(new_collection_schema)

            time.sleep(self.trigger_interval)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.sync_ends_service.SyncEnd.compute_difference"><code class="name flex">
<span>def <span class="ident">compute_difference</span></span>(<span>self, new_collection_schema)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the difference between the new and the old collection
schema. The old collection schema is stored as a file in the
data/ directory.</p>
<h2 id="inputs">Inputs</h2>
<pre><code>new_collection_schema : dictionary representing the collection schema fetched through the Postman API
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def compute_difference(self, new_collection_schema):
        &#34;&#34;&#34;
        Computes the difference between the new and the old collection \
        schema. The old collection schema is stored as a file in the \
        data/ directory.

        Inputs
        ----------
            new_collection_schema : dictionary representing the collection \
schema fetched through the Postman API
        &#34;&#34;&#34;

        # specify the filepath for the collection schema, create the file if \
        # not already present
        filepath = &#34;./data/&#34; + self.collection_id + &#34;.txt&#34;
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        if not os.path.exists(filepath):
            with open(filepath, &#34;w&#34;) as file:
                # file.write(&#34;{\&#34;item\&#34;:[]}&#34;)
                file.write(json.dumps(new_collection_schema.get(&#34;collection&#34;)))

        # the old (previous) collection schema is stored as a file in data/
        file = open(filepath, &#34;r&#34;)
        old_collection_schema = json.load(file)

        # read the data from file and convert it to collection object
        old_schema_obj = Collection(old_collection_schema)
        new_collection_obj = Collection(
            new_collection_schema.get(&#34;collection&#34;)
        )  # noqa: E501

        # iterate over each new endpoint(API) in the collection and compare
        # with old endpoint
        common_end_points = []
        for new_end_point in new_collection_obj.get_end_points():
            for old_end_point in old_schema_obj.get_end_points():

                # if same id endpoint in both old and new schemas, add it
                # to common_end_points, remove it from old endpoints
                # and new endpoints
                if new_end_point.id == old_end_point.id:
                    # if same id ,
                    # append it to common_end_points list
                    common_end_points.append((new_end_point, old_end_point))
                    old_schema_obj.remove_end_point(old_end_point)
                    new_collection_obj.remove_end_point(new_end_point)

        # at the end of above for loop, the 3 objects store the following information:  # noqa: E501
        # old_schema_obj - only those endpoints which are now deleted from the collection  # noqa: E501
        # new_collection_obj - only those endpoints which have been added to the collection  # noqa: E501
        # common_end_points - only those endpoints which are common b/w old and new collection schemas  # noqa: E501

        newly_added_end_point = self.get_newly_added_message(
            new_collection_obj.get_end_points()
        )

        deleted_end_points = self.get_delete_message(old_schema_obj.get_end_points())  # noqa: E501

        updated_end_point = self.get_updated_end_point_message(common_end_points)  # noqa: E501

        message = [
            newly_added_end_point,
            deleted_end_points,
            updated_end_point,
        ]

        return message</code></pre>
</details>
</dd>
<dt id="src.sync_ends_service.SyncEnd.get_collection_schema"><code class="name flex">
<span>def <span class="ident">get_collection_schema</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches the APIs schemas from the Postman collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_collection_schema(self):
    &#34;&#34;&#34;
    Fetches the APIs schemas from the Postman collection
    &#34;&#34;&#34;

    boundary = &#34;&#34;
    payload = &#34;&#34;
    headers = {
        &#34;X-Api-Key&#34;: self.api_key,
        &#34;Content-type&#34;: &#34;multipart/form-data; boundary={}&#34;.format(boundary),  # noqa: E501
    }

    # create a HTTPS connection object
    connection = http.client.HTTPSConnection(&#34;api.getpostman.com&#34;)
    connection.request(&#34;GET&#34;, &#34;/collections&#34;, payload, headers)
    response = connection.getresponse()
    collections = json.loads(response.read())
    collection = list(
        filter(
            lambda x: self.collection_name == x[&#34;name&#34;],
            collections.get(&#34;collections&#34;),
        )
    )

    # if collection is empty, it is an invalid connection
    if len(collection) == 0:
        raise NameError(&#34;Invalid collection name !!!&#34;)

    self.collection_id = collection[0][&#34;uid&#34;]
    connection.request(
        &#34;GET&#34;, &#34;/collections/&#34; + self.collection_id, payload, headers
    )

    # fetch the response and load the API schema as a JSON
    collection_schema_response = connection.getresponse()
    return json.loads(collection_schema_response.read())</code></pre>
</details>
</dd>
<dt id="src.sync_ends_service.SyncEnd.get_delete_message"><code class="name flex">
<span>def <span class="ident">get_delete_message</span></span>(<span>self, end_point_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the message string for each API end point deleted from the
collection</p>
<h2 id="inputs">Inputs</h2>
<pre><code>end_point_list : list of endpoints which are deleted from the collection
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def get_delete_message(self, end_point_list):
        &#34;&#34;&#34;
        Returns the message string for each API end point deleted from the \
        collection

        Inputs
        ----------
            end_point_list : list of endpoints which are deleted from the \
collection
        &#34;&#34;&#34;
        title = &#34;Following end points are deleted from the collection :: \n\n&#34;
        output = &#34;&#34;
        for i, end_point in enumerate(end_point_list):
            output = (
                output
                + &#34;\t&#34;
                + str(i + 1)
                + &#34;)  &#34;
                + &#34;EndPoint Name: &#34;
                + end_point.name
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;URL: &#34;
                + end_point.url
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;Request Method: &#34;
                + end_point.method
                + &#34;\n\n&#34;
            )
        if output == &#34;&#34;:
            return None
        return title + output</code></pre>
</details>
</dd>
<dt id="src.sync_ends_service.SyncEnd.get_newly_added_message"><code class="name flex">
<span>def <span class="ident">get_newly_added_message</span></span>(<span>self, end_point_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the message string for each API end point added to the
collection</p>
<h2 id="inputs">Inputs</h2>
<pre><code>end_point_list : list of endpoints which are newly added to the collection
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def get_newly_added_message(self, end_point_list):
        &#34;&#34;&#34;
        Returns the message string for each API end point added to the \
        collection

        Inputs
        ----------
            end_point_list : list of endpoints which are newly added to the \
collection
        &#34;&#34;&#34;
        title = &#34;Following end points are newly added in the collection :: \n\n&#34;  # noqa: E501
        output = &#34;&#34;
        for i, end_point in enumerate(end_point_list):
            output = (
                output
                + &#34;\t&#34;
                + str(i + 1)
                + &#34;)  &#34;
                + end_point.name
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;URL: &#34;
                + end_point.url
                + &#34;\n&#34;
                + &#34;\t&#34;
                + &#34;Request Method: &#34;
                + end_point.method
                + &#34;\n\n&#34;
            )
        if output == &#34;&#34;:
            return None
        return title + output</code></pre>
</details>
</dd>
<dt id="src.sync_ends_service.SyncEnd.get_updated_end_point_message"><code class="name flex">
<span>def <span class="ident">get_updated_end_point_message</span></span>(<span>self, common_end_points)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the message string for each API end point updated in the
collection</p>
<h2 id="inputs">Inputs</h2>
<pre><code>common_end_points : list of endpoints (APIs) which are modified in the collection
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def get_updated_end_point_message(self, common_end_points):
        &#34;&#34;&#34;
        Returns the message string for each API end point updated in the \
        collection

        Inputs
        ----------
            common_end_points : list of endpoints (APIs) which are modified \
in the collection
        &#34;&#34;&#34;
        title = &#34;Following is the list of change in the existing end points ::\n\n&#34;  # noqa: E501
        difference = &#34;&#34;
        for end_point_tuple in common_end_points:
            difference = &#34;&#34;
            new_end_point = end_point_tuple[0]
            old_end_point = end_point_tuple[1]

            # compute change in name
            if new_end_point.name != old_end_point.name:
                difference += (
                    &#34;\tNew name: &#34;
                    + new_end_point.name
                    + &#34; &#34;
                    + &#34;\nOld name: &#34;
                    + old_end_point.name
                    + &#34;\n&#34;
                )

            if new_end_point.url != old_end_point.url:
                difference += (
                    &#34;\tNew URL: &#34;
                    + new_end_point.url
                    + &#34; &#34;
                    + &#34;\nOld URL: &#34;
                    + old_end_point.url
                    + &#34;\n&#34;
                )

            # compute change in authentication
            if new_end_point.authentication != old_end_point.authentication:
                if new_end_point.authentication is None:
                    difference += &#34;\tNew Authentication: None&#34;
                else:
                    difference += (
                        &#34;\tNew Authentication: Key :&#34;
                        + new_end_point.authentication[&#34;apikey&#34;][1][&#34;value&#34;]
                        + &#34;, Value : &#34;
                        + new_end_point.authentication[&#34;apikey&#34;][0][&#34;value&#34;]
                        + &#34;\n&#34;
                    )

            # Compute change in the HTTP request type
            if new_end_point.method != old_end_point.method:
                difference += (
                    &#34;\t New HTTP method: &#34;
                    + new_end_point.method
                    + &#34; &#34;
                    + &#34;\nOld HTTP method: &#34;
                    + old_end_point.method
                    + &#34;\n&#34;
                )

        if difference == &#34;&#34;:
            return None

        return title + difference</code></pre>
</details>
</dd>
<dt id="src.sync_ends_service.SyncEnd.post_data_to_slack"><code class="name flex">
<span>def <span class="ident">post_data_to_slack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Posts the messages for APIs added, deleted and updated based on the
input data</p>
<h2 id="inputs">Inputs</h2>
<pre><code>data : list of strings pertaining to APIs added, deleted and updated
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def post_data_to_slack(self, data):
        &#34;&#34;&#34;
        Posts the messages for APIs added, deleted and updated based on the \
        input data

        Inputs
        ----------
            data : list of strings pertaining to APIs added, deleted and \
updated
        &#34;&#34;&#34;
        slack_web_client = WebClient(
            # Add the slack access token here
            token=self.slack_token
        )

        for x in data:
            if x is not None and len(x) &gt; 0:
                message = {
                    &#34;channel&#34;: self.slack_channel,
                    &#34;blocks&#34;: [
                        {
                            &#34;type&#34;: &#34;section&#34;,
                            &#34;text&#34;: {&#34;type&#34;: &#34;plain_text&#34;, &#34;text&#34;: x},
                        }
                    ],
                }
                slack_web_client.chat_postMessage(**message)</code></pre>
</details>
</dd>
<dt id="src.sync_ends_service.SyncEnd.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Main driver function which is called from main.py to run CLI.
This function fetches the new collection schema through Postman API.
Then, it computes the difference with old schema and posts the
relevant messages to Slack channel.
Finally, it overwrites the new schema fetched through the API in the
file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Main driver function which is called from main.py to run CLI. \
    This function fetches the new collection schema through Postman API.
    Then, it computes the difference with old schema and posts the \
    relevant messages to Slack channel.
    Finally, it overwrites the new schema fetched through the API in the \
    file.
    &#34;&#34;&#34;
    while True:

        # get the current configuration of the schema
        new_collection_schema = self.get_collection_schema()

        # compute the difference with the previous schema
        difference = self.compute_difference(new_collection_schema)

        # post the difference to the slack
        self.post_data_to_slack(difference)

        # store new schema to the file
        self.store_file(new_collection_schema)

        time.sleep(self.trigger_interval)</code></pre>
</details>
</dd>
<dt id="src.sync_ends_service.SyncEnd.store_file"><code class="name flex">
<span>def <span class="ident">store_file</span></span>(<span>self, new_collection)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the collection schema as a txt file in data/ directory. This
will be used to fetch the schema in compute_difference().</p>
<h2 id="inputs">Inputs</h2>
<pre><code>new_collection : collection schema to be saved in the file
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_file(self, new_collection):
    &#34;&#34;&#34;
    Stores the collection schema as a txt file in data/ directory. This \
    will be used to fetch the schema in compute_difference().

    Inputs
    ----------
        new_collection : collection schema to be saved in the file
    &#34;&#34;&#34;
    filepath = &#34;./data/&#34; + self.collection_id + &#34;.txt&#34;
    with open(filepath, &#34;w&#34;) as file:
        file.write(json.dumps(new_collection.get(&#34;collection&#34;)))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.sync_ends_service.SyncEnd" href="#src.sync_ends_service.SyncEnd">SyncEnd</a></code></h4>
<ul class="">
<li><code><a title="src.sync_ends_service.SyncEnd.compute_difference" href="#src.sync_ends_service.SyncEnd.compute_difference">compute_difference</a></code></li>
<li><code><a title="src.sync_ends_service.SyncEnd.get_collection_schema" href="#src.sync_ends_service.SyncEnd.get_collection_schema">get_collection_schema</a></code></li>
<li><code><a title="src.sync_ends_service.SyncEnd.get_delete_message" href="#src.sync_ends_service.SyncEnd.get_delete_message">get_delete_message</a></code></li>
<li><code><a title="src.sync_ends_service.SyncEnd.get_newly_added_message" href="#src.sync_ends_service.SyncEnd.get_newly_added_message">get_newly_added_message</a></code></li>
<li><code><a title="src.sync_ends_service.SyncEnd.get_updated_end_point_message" href="#src.sync_ends_service.SyncEnd.get_updated_end_point_message">get_updated_end_point_message</a></code></li>
<li><code><a title="src.sync_ends_service.SyncEnd.post_data_to_slack" href="#src.sync_ends_service.SyncEnd.post_data_to_slack">post_data_to_slack</a></code></li>
<li><code><a title="src.sync_ends_service.SyncEnd.start" href="#src.sync_ends_service.SyncEnd.start">start</a></code></li>
<li><code><a title="src.sync_ends_service.SyncEnd.store_file" href="#src.sync_ends_service.SyncEnd.store_file">store_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>